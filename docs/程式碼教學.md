# GraphRAG 程式碼教學

本教學逐檔逐函數介紹 GraphRAG Practice Lab 的實作，協助你理解從資料載入、切分、實體關聯推斷，到圖譜檢索與 Gemini 整合的完整流程。閱讀順序採由核心套件開始，再延伸至指令列腳本。每節提供：功能說明、函數簽名、輸入/輸出、邊界條件、實用範例與延伸建議。

---

## 專案概觀

- `graphrag/`：核心套件，依管線階段分模組。
- `scripts/`：提供命令列介面，便於演練與驗證。
- `data/`：存放原始文本示例，供管線載入與測試。
- `docs/`：文件區，本教學檔與快速指南皆位於此。

---

## graphrag/__init__.py

- `GraphRAGPipeline`：自 `pipeline` 模組重新匯出，讓使用者透過 `from graphrag import GraphRAGPipeline` 簡化引用。

範例：
```python
from pathlib import Path
from graphrag import GraphRAGPipeline

pipeline = GraphRAGPipeline.from_path(Path("data"))
print(pipeline.explain_graph())
```

---

## graphrag/data_loader.py

- 常數 `SUPPORTED_EXTENSIONS`：宣告支援的文件副檔名，預設為 `.txt`、`.md`。
- 資料類別 `Document`：包裝單一文件的 `doc_id`（路徑字串）、`title`（檔名轉標題）、`body`（全文）。
- 函數 `iter_documents(path: Path) -> Iterable[Document]`
  - 逐一讀取指定路徑：若為檔案直接載入；若為目錄則遞迴搜尋支援的檔案並產生 `Document`。
- 函數 `load_documents(path: Path) -> List[Document]`
  - 將 `iter_documents` 轉成清單，方便後續需要完整常駐記憶體的情境。
- 私有函數 `_load_file(path: Path) -> Document`
  - 讀取單一檔案並建立 `Document`。同時將檔名中的底線轉換為空白並標題化，作為預設標題格式。

邊界條件與注意事項：
- 僅處理 `SUPPORTED_EXTENSIONS = {".txt", ".md"}`；其他副檔名會被略過。
- 讀檔以 `utf-8` 編碼，若檔案非 UTF-8 可能引發例外。

範例：
```python
from pathlib import Path
from graphrag.data_loader import load_documents

docs = load_documents(Path("data"))
print(len(docs), docs[0].title)
```

---

## graphrag/chunker.py

- 資料類別 `Chunk`：描述圖譜 ingest 的最小單位，包含 `chunk_id`（來源文件+索引）、`doc_id`（原文件 ID）、`text`（片段內容）。
- 函數 `chunk_document(document: Document, max_tokens: int = 120, overlap: int = 20) -> List[Chunk]`
  - 將文件文字以空白切詞，用重疊窗口（約略模擬 token 上限）切分成多個 chunk。重疊長度預設 20 以保留跨片段語境。
- 函數 `chunk_corpus(documents: Iterable[Document]) -> List[Chunk]`
  - 批次套用 `chunk_document`，回傳完整 chunk 清單，供下游實體抽取與嵌入計算使用。

邊界條件與注意事項：
- 文件極短時可能只產生單一 chunk。
- 若 `overlap >= max_tokens`，會造成高度重疊；請依需求調整以避免過多冗餘。

範例：
```python
from graphrag.chunker import chunk_document
from graphrag.data_loader import Document

doc = Document(doc_id="demo.txt", title="Demo", body="A B C D E F G H I J")
chunks = chunk_document(doc, max_tokens=4, overlap=1)
for c in chunks:
    print(c.chunk_id, c.text)
```

---

## graphrag/entity_extraction.py

- 正則 `ENTITY_PATTERN`：偵測以大寫開頭的單詞或多詞片段，是範例中簡化的實體擷取策略。
- 資料類別 `Entity`：紀錄 `entity_id`（小寫+底線）、`label`（原字串）、`frequency`（出現次數）。
- 資料類別 `Relation`：描述實體間聯結，包含來源 `head_id`、目標 `tail_id`、`weight`（共現次數）、`description`（簡述）。
- 函數 `extract_entities(chunks: Iterable[Chunk], min_freq: int = 2) -> Dict[str, Entity]`
  - 掃描每個 chunk，以正則比對所有候選實體並計數。僅保留出現頻率達門檻的實體，並以標籤轉換成 `entity_id`。
- 函數 `extract_relations(chunks: Iterable[Chunk], entities: Dict[str, Entity]) -> List[Relation]`
  - 對每個 chunk 中出現的實體組合計算共現次數，形成無向邊。結果轉為 `Relation` 物件，描述實體間的共現關係。

邊界條件與注意事項：
- 實體抽取對大小寫敏感；若語料未良好標記專有名詞，可能抓不到關鍵詞。
- 關係抽取以共現近似語義關聯，建議後續以權重或距離調整。

範例：
```python
from graphrag.entity_extraction import extract_entities, extract_relations
from graphrag.chunker import Chunk

chunks = [Chunk(chunk_id="c1", doc_id="d1", text="GraphRAG uses Knowledge Graphs in Retrieval")]
entities = extract_entities(chunks, min_freq=1)
relations = extract_relations(chunks, entities)
print(list(entities.keys()), [(r.head_id, r.tail_id, r.weight) for r in relations])
```

---

## graphrag/embedder.py

- 正則 `TOKEN_PATTERN` 與函數 `tokenize(text: str) -> List[str]`：將文字轉為小寫並擷取字母、數字組成的 token。
- 資料類別 `Embedding`：包括 `key`（例如 chunk_id）與對應向量 `vector`。
- 類別 `BagOfWordsEmbedder`：簡易 TF-IDF 風格嵌入器。
  - `fit(documents: Iterable[str]) -> None`：建立字彙表與逆文件頻率（IDF）。採用加一平滑 `log(1 + N / (1 + df))` 避免除零。
  - `transform(text: str) -> List[float]`：以 `0.5 + 0.5 * (count / max_count)` 計算 TF，再乘以 IDF。需先呼叫 `fit`。
  - `fit_transform_chunks(chunks: Iterable[Chunk]) -> Dict[str, Embedding]`：整合前兩步，回傳 `chunk_id -> Embedding`。
- 函數 `cosine_similarity(vec_a: List[float], vec_b: List[float]) -> float`：計算向量間餘弦相似度；若任一向量為零，回傳 0.0。

邊界條件與注意事項：
- 語料過小或詞彙分散，易產生稀疏零向量；可考慮移除停用詞或採用子詞/字 n-gram。

範例：
```python
from graphrag.embedder import BagOfWordsEmbedder, cosine_similarity

emb = BagOfWordsEmbedder()
emb.fit(["GraphRAG blends graphs and vectors", "Graphs improve retrieval"])
q = emb.transform("graph retrieval")
c = emb.transform("graphs improve retrieval")
print(cosine_similarity(q, c))
```

---

## graphrag/graph_builder.py

- 型別別名 `Graph = nx.Graph`：使用 NetworkX 無向圖做為圖譜結構。
- 函數 `build_graph(chunks: Iterable[Chunk], entities: Dict[str, Entity], relations: Iterable[Relation]) -> Graph`  
  建立異質圖：
  - chunk 節點屬性：`type="chunk"`, `doc_id`, `text`
  - entity 節點屬性：`type="entity"`, `label`, `frequency`
  - `mentions` 邊（chunk→entity）：`weight=1.0`
  - `co_occurs` 邊（entity↔entity）：`weight=共現次數`, `description`

注意：使用 `if entity.label in chunk.text` 進行字串包含判斷，可能導致假陽性（子字串碰撞）。實務上可改以 token 邊界或位移索引對齊。

---

## graphrag/visualization.py

- 類別 `VisualisationConfig`：封裝繪圖設定（佈局演算法、節點數上限、鄰近半徑、是否顯示標籤、亂數種子）。
- 函數 `select_subgraph(graph, focus_nodes=None, max_nodes=200, include_neighbors_radius=2)`  
  - 根據焦點節點（及其鄰居）或節點上限挑選子圖，避免整張圖過於複雜。
- 函數 `compute_layout(graph, layout="spring", seed=42)`  
  - 支援 `spring`、`kamada_kawai`、`spectral`、`shell` 等 networkx 佈局。
- 函數 `draw_graph(graph, output_path, config, focus_nodes=None)`  
  - 呼叫上述工具篩選/佈局後，以 matplotlib (`Agg` 後端) 繪圖，對 chunk 與 entity 節點使用不同顏色，並可選擇是否顯示文字標籤。

邊界條件與注意事項：
- 若傳入的焦點節點不存在，函數會拋出錯誤提示呼叫者檢查輸入。
- 若子圖節點數仍超過 `config.max_nodes`，會再次裁剪前若干節點，確保輸出的圖像可讀。

範例：
```python
from pathlib import Path
from graphrag import GraphRAGPipeline
from graphrag.visualization import VisualisationConfig, draw_graph

pipeline = GraphRAGPipeline.from_path(Path("data"))
draw_graph(
    pipeline.artifacts.graph,
    Path("graphrag_graph.png"),
    config=VisualisationConfig(layout="spring", max_nodes=150, with_labels=True),
    focus_nodes=["data/example.txt::chunk-0"],
)
```

---

## graphrag/retrieval.py

- 資料類別 `RetrievalResult`：儲存檢索結果，包括 `chunk_id`、`score`、`text`、`trail`（表示圖中追蹤路徑）。
- 類別 `GraphRetriever`：結合向量檢索與圖擴充的檢索器。
  - 建構子 `__init__(graph, chunk_index, embedder, chunk_embeddings)`：接受圖、chunk 索引、嵌入器與事先計算的 chunk 向量。
  - 方法 `query(text: str, k: int = 5) -> List[RetrievalResult]`：
    1. 提問向量化。
    2. `_score_chunks` 排序取前 k。
    3. `_expand_via_graph` 走訪 `chunk -> entity -> chunk`，擴展分數 = `base * 0.8`，記錄 trail。
  - 私有方法 `_score_chunks(query_vec)`：對每個 chunk 計算餘弦相似度並排序。
  - 私有方法 `_expand_via_graph(top_chunks)`：以 `visited` 集合避免重複；保留原始 top-k 於結果中。

範例：
```python
from graphrag.retrieval import GraphRetriever

chunk_index = {c.chunk_id: c for c in chunks}
retriever = GraphRetriever(graph=G, chunk_index=chunk_index, embedder=emb, chunk_embeddings={k: e.vector for k, e in emb.fit_transform_chunks(chunks).items()})
for r in retriever.query("What is GraphRAG?", k=5)[:3]:
    print(r.score, "->", " -> ".join(r.trail))
```

---

## graphrag/gemini.py

- 例外類別 `GeminiImportError`：當未安裝 `google-generativeai` 時拋出。
- 資料類別 `GeminiConfig`：封裝 API 設定，含 `api_key`、`model`、`temperature`、`max_output_tokens`。
  - `__post_init__`：正規化模型名稱，確保有 `models/` 前綴。
  - 類別方法 `from_env`：支援透過環境變數或 `.env` 檔載入金鑰。
- 函數 `_normalise_model_name(name: str) -> str`：補齊模型名稱前綴。
- 類別 `GeminiAnswerGenerator`：負責呼叫 Gemini 生成回答。
  - 建構子：載入 SDK、設定 API Key、初始化模型實例，並儲存溫度與輸出長度。
  - 方法 `build_prompt(question, contexts)`：依檢索片段組合提示詞，要求模型提供附證據的 Markdown 作答。
  - 方法 `answer(question, contexts)`：檢查上下文是否存在、呼叫模型 `generate_content`，處理回傳文字或終止原因（若僅回傳 finish reason，建議調整 `--top-k` 或 `--gemini-max-output-tokens`）。
- 函數 `_extract_primary_text(response)`：從 SDK 回傳物件擷取第一段文字內容。
- 函數 `_first_finish_reason(response)`：擷取第一個候選的終止原因，協助錯誤訊息提示。

安裝與環境：
- 若未安裝 `google-generativeai`，會拋出 `GeminiImportError`。請先安裝：
  ```bash
  pip install google-generativeai python-dotenv
  ```
- `GeminiConfig.from_env` 首次呼叫會載入 `.env`，並從 `GOOGLE_GEMINI_API_KEY` 或指定環境變數讀取金鑰；模型名稱可省略 `models/` 前綴。

範例：
```python
from graphrag.gemini import GeminiConfig, GeminiAnswerGenerator

cfg = GeminiConfig.from_env(model="gemini-1.5-flash", max_output_tokens=512)
generator = GeminiAnswerGenerator(cfg)
print(generator.answer("Explain GraphRAG", ["GraphRAG blends vectors and graphs."]))
```

---

## graphrag/pipeline.py

- 資料類別 `PipelineArtifacts`：集中記錄管線組件（文件、chunk、實體、圖、嵌入、嵌入器），方便重複使用或導出。
- 類別 `GraphRAGPipeline`：對外提供高層 API。
  - 建構子 `__init__(artifacts)`：儲存成果並建立 `GraphRetriever` 實例。
  - 類別方法 `from_path(path: Path)`：
    1. 載入文件、切 chunk。
    2. 擷取實體與關係並建圖。
    3. 訓練嵌入器、計算 chunk 向量。
    4. 將成果打包成 `PipelineArtifacts` 回傳管線實例。
  - 方法 `retrieve(question: str, top_k: int = 5)`：直接呼叫 `GraphRetriever`，回傳檢索結果清單。
- 方法 `query(question: str, top_k: int = 3) -> str`：
    1. 檢索前 `top_k` 個結果。
    2. 透過 `_synthesise_answer` 以前三筆結果的第一句組合成條列式回答。
    3. 回傳包含問題、回答、上下文與走訪 trail 的格式化字串。
  - 方法 `query_with_gemini(...) -> str`：
    1. 先檢索上下文。
    2. 建立 `GeminiConfig`（可由參數或環境讀取金鑰）。
    3. 呼叫 `GeminiAnswerGenerator` 生成回答，最後與上下文 trail 一起輸出。
  - 方法 `explain_graph() -> str`：統計圖中節點類型數量、邊數、文件與 chunk 數量，輸出簡易摘要。
- 私有方法 `_synthesise_answer(question, results)`：根據前幾筆檢索結果擷取第一句形成條列回應，若無結果則回傳預設提示。

延伸建議：
- 想要更好的摘要可改寫 `_synthesise_answer` 或接入任意 LLM；若需可控長度與格式，建議搭配範本與關鍵詞約束。
- 若要做批量處理，將 `PipelineArtifacts` 序列化至磁碟（如 pickle 或自定格式），避免重複計算嵌入與圖。

端到端範例：
```python
from pathlib import Path
from graphrag import GraphRAGPipeline

p = GraphRAGPipeline.from_path(Path("data"))
print(p.explain_graph())
print(p.query("GraphRAG 如何利用知識圖譜？", top_k=3))
# Gemini（需設定金鑰與安裝 SDK）
# print(p.query_with_gemini("GraphRAG 如何利用知識圖譜？", top_k=3))
```

---

## scripts/build_graph.py

- 函數 `parse_args() -> argparse.Namespace`：定義資料路徑與 `--export-graphml` 參數。
- 函數 `main()`：
  1. 解析參數後建立管線。
  2. 呼叫 `explain_graph` 輸出圖譜摘要。
  3. 若指定 `--export-graphml`，則將圖寫入對應檔案並提示路徑。
- `if __name__ == "__main__": main()`：允許直接由命令列執行。

注意：
- 檔案開頭以 `sys.path.append` 將倉庫根目錄加入模組搜尋路徑，確保可直接 `from graphrag import GraphRAGPipeline`。

---

## scripts/visualize_graph.py

- 函數 `parse_args()`：定義資料路徑、輸出檔、佈局、節點上限、鄰近半徑，及可選的 `--focus-question` / `--top-k` / `--with-labels` 參數。
- 函數 `main()`：
  1. 建立 `GraphRAGPipeline` 並取得圖譜。
  2. 若提供 `--focus-question`，先進行檢索並收集 chunk 與 trail 節點做為焦點。
  3. 建立 `VisualisationConfig`，呼叫 `draw_graph` 將快照輸出為 PNG 並在終端顯示節點/邊統計。
- `if __name__ == "__main__": main()`：支援直接執行。

注意：
- 需在環境中安裝 `matplotlib`（已列於 `requirements.txt`）。若於伺服器環境使用，指令會透過 `Agg` 後端直接產生檔案，不會開啟視窗。
- 建議在節點數量龐大時搭配 `--max-nodes` 或 `--focus-question` 以維持可讀性。

---

## scripts/query_graph.py

- 函數 `parse_args()`：
  - `data_path`：資料來源路徑。
  - `question`：自然語言問題。
  - `--top-k`：返回的上下文數量。
  - `--use-gemini` 及相關 `gemini-` 前綴參數：控制是否啟用 Gemini、模型名稱、溫度、輸出限制、金鑰來源等。
- 函數 `main()`：
  1. 建立 `GraphRAGPipeline`。
  2. 根據 `--use-gemini` 選擇呼叫 `query` 或 `query_with_gemini`。
  3. 將回答與上下文直接印出，方便手動檢查。
- `if __name__ == "__main__": main()`：支援直接執行。

注意：
- 預設 Gemini 模型名稱為 `models/gemini-1.5-flash`；可直接填 `gemini-1.5-flash-lite` 等短名，程式會自動補上 `models/` 前綴。
- 若僅回傳 finish reason，請減小 `--top-k`、縮短提示或調大 `--gemini-max-output-tokens`。

---

## 學習路線建議

1. 由 `data_loader.py` 至 `graph_builder.py` 逐步實際執行每個函數，觀察中間資料結構。
2. 在 Python 互動環境中實驗 `GraphRetriever.query`，理解向量分數與圖擴展帶來的 trail。
3. 修改 `GeminiAnswerGenerator.build_prompt` 的指令語氣，感受輸出風格的變化。
4. 撰寫單元測試覆蓋每個模組的主要函數，加深邏輯掌握。

掌握上述模組後，你即能清楚理解 GraphRAG 管線的運作模式，並依需求替換每個階段的實作。祝學習順利！

加分挑戰：
- 將檢索擴展策略改為個人化 PageRank 或多跳 BFS，並在文件加入前後效果比較。
- 將 `mentions` 邊權重改為依距離或 TF-IDF 權重，觀察排序變化。
- 以 `tests/` 建立小型回歸集（問題→預期前幾名 chunk_id），避免後續調整造成品質回退。
